# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class AchievementActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Achievement]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Achievement.prisma().query_raw(
            'SELECT * FROM Achievement WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Achievement
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Achievement.prisma().query_first(
            'SELECT * FROM Achievement WHERE operatorId = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AchievementCreateInput,
        include: Optional[types.AchievementInclude] = None
    ) -> _PrismaModelT:
        """Create a new Achievement record.

        Parameters
        ----------
        data
            Achievement record data
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The created Achievement record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Achievement record from just the required fields
        achievement = await Achievement.prisma().create(
            data={
                # data to create a Achievement record
                'operatorId': 'ggciceaie',
                'achievementType': 'bbehjachib',
                'timestamp': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AchievementCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Achievement records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Achievement record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Achievement.prisma().create_many(
            data=[
                {
                    # data to create a Achievement record
                    'operatorId': 'cadfabfehe',
                    'achievementType': 'dgiiaaijj',
                    'timestamp': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Achievement record
                    'operatorId': 'bfaiacjjfc',
                    'achievementType': 'eigcfgbif',
                    'timestamp': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Achievement record.

        Parameters
        ----------
        where
            Achievement filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The deleted Achievement record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().delete(
            where={
                'id': 'bagcfbhiig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Achievement record.

        Parameters
        ----------
        where
            Achievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The found Achievement record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().find_unique(
            where={
                'id': 'cghideieh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Achievement record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Achievement filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The found Achievement record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().find_unique_or_raise(
            where={
                'id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
        include: Optional[types.AchievementInclude] = None,
        order: Optional[Union[types.AchievementOrderByInput, List[types.AchievementOrderByInput]]] = None,
        distinct: Optional[List[types.AchievementScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Achievement records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Achievement records returned
        skip
            Ignore the first N results
        where
            Achievement filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Achievement model
        order
            Order the returned Achievement records by any field
        distinct
            Filter Achievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Achievement]
            The list of all Achievement records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Achievement records
        achievements = await Achievement.prisma().find_many(take=10)

        # find the first 5 Achievement records ordered by the achievementType field
        achievements = await Achievement.prisma().find_many(
            take=5,
            order={
                'achievementType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
        include: Optional[types.AchievementInclude] = None,
        order: Optional[Union[types.AchievementOrderByInput, List[types.AchievementOrderByInput]]] = None,
        distinct: Optional[List[types.AchievementScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Achievement record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Achievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Achievement model
        order
            Order the returned Achievement records by any field
        distinct
            Filter Achievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Achievement
            The first Achievement record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Achievement record ordered by the timestamp field
        achievement = await Achievement.prisma().find_first(
            skip=1,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
        include: Optional[types.AchievementInclude] = None,
        order: Optional[Union[types.AchievementOrderByInput, List[types.AchievementOrderByInput]]] = None,
        distinct: Optional[List[types.AchievementScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Achievement record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Achievement filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Achievement model
        order
            Order the returned Achievement records by any field
        distinct
            Filter Achievement records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Achievement
            The first Achievement record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Achievement record ordered by the id field
        achievement = await Achievement.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AchievementUpdateInput,
        where: types.AchievementWhereUniqueInput,
        include: Optional[types.AchievementInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Achievement record.

        Parameters
        ----------
        data
            Achievement record data specifying what to update
        where
            Achievement filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The updated Achievement record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        achievement = await Achievement.prisma().update(
            where={
                'id': 'idghgaicb',
            },
            data={
                # data to update the Achievement record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AchievementWhereUniqueInput,
        data: types.AchievementUpsertInput,
        include: Optional[types.AchievementInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Achievement filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Achievement model

        Returns
        -------
        prisma.models.Achievement
            The created or updated Achievement record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        achievement = await Achievement.prisma().upsert(
            where={
                'id': 'fjfddhigg',
            },
            data={
                'create': {
                    'id': 'fjfddhigg',
                    'operatorId': 'bfaiacjjfc',
                    'achievementType': 'eigcfgbif',
                    'timestamp': datetime.datetime.utcnow(),
                },
                'update': {
                    'operatorId': 'bfaiacjjfc',
                    'achievementType': 'eigcfgbif',
                    'timestamp': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AchievementUpdateManyMutationInput,
        where: types.AchievementWhereInput,
    ) -> int:
        """Update multiple Achievement records

        Parameters
        ----------
        data
            Achievement data to update the selected Achievement records to
        where
            Filter to select the Achievement records to update

        Returns
        -------
        int
            The total number of Achievement records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Achievement records
        total = await Achievement.prisma().update_many(
            data={
                'operatorId': 'hjaecfifb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Achievement records present in the database

        Parameters
        ----------
        select
            Select the Achievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Achievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Achievement.prisma().count()

        # results: prisma.types.AchievementCountAggregateOutput
        results = await Achievement.prisma().count(
            select={
                '_all': True,
                'achievementType': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AchievementCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
    ) -> types.AchievementCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AchievementCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AchievementWhereInput] = None,
        cursor: Optional[types.AchievementWhereUniqueInput] = None,
    ) -> Union[int, types.AchievementCountAggregateOutput]:
        """Count the number of Achievement records present in the database

        Parameters
        ----------
        select
            Select the Achievement fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Achievement filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AchievementCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Achievement.prisma().count()

        # results: prisma.types.AchievementCountAggregateOutput
        results = await Achievement.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AchievementCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AchievementWhereInput] = None
    ) -> int:
        """Delete multiple Achievement records.

        Parameters
        ----------
        where
            Optional Achievement filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Achievement records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Achievement records
        total = await Achievement.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AchievementScalarFieldKeys'],
        *,
        where: Optional['types.AchievementWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AchievementAvgAggregateInput'] = None,
        sum: Optional['types.AchievementSumAggregateInput'] = None,
        min: Optional['types.AchievementMinAggregateInput'] = None,
        max: Optional['types.AchievementMaxAggregateInput'] = None,
        having: Optional['types.AchievementScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AchievementCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AchievementScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AchievementScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AchievementGroupByOutput']:
        """Group Achievement records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Achievement fields to group records by
        where
            Achievement filter to select records
        take
            Limit the maximum number of Achievement records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AchievementGroupByOutput]
            A list of dictionaries representing the Achievement record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Achievement records by id values
        # and count how many records are in each group
        results = await Achievement.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CameraActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Camera]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Camera.prisma().query_raw(
            'SELECT * FROM Camera WHERE id = $1',
            'cbbbjbfcii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Camera
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Camera.prisma().query_first(
            'SELECT * FROM Camera WHERE name = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CameraCreateInput,
        include: Optional[types.CameraInclude] = None
    ) -> _PrismaModelT:
        """Create a new Camera record.

        Parameters
        ----------
        data
            Camera record data
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The created Camera record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Camera record from just the required fields
        camera = await Camera.prisma().create(
            data={
                # data to create a Camera record
                'name': 'bgeecijdgg',
                'liveUrl': 'bdiicjafbj',
                'geo': 'bgehebiafc',
                'location': Base64.encode(b'bghffegacj'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CameraCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Camera records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Camera record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Camera.prisma().create_many(
            data=[
                {
                    # data to create a Camera record
                    'name': 'bhghchehcc',
                    'liveUrl': 'dcgchcbbf',
                    'geo': 'bdedcabahc',
                    'location': Base64.encode(b'ghfhiafcb'),
                },
                {
                    # data to create a Camera record
                    'name': 'heejgedji',
                    'liveUrl': 'bjgjgibgbf',
                    'geo': 'bbbgbhfjge',
                    'location': Base64.encode(b'igbehcbab'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CameraWhereUniqueInput,
        include: Optional[types.CameraInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Camera record.

        Parameters
        ----------
        where
            Camera filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The deleted Camera record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        camera = await Camera.prisma().delete(
            where={
                'id': 'bdadaadhag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CameraWhereUniqueInput,
        include: Optional[types.CameraInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Camera record.

        Parameters
        ----------
        where
            Camera filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The found Camera record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        camera = await Camera.prisma().find_unique(
            where={
                'id': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CameraWhereUniqueInput,
        include: Optional[types.CameraInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Camera record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Camera filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The found Camera record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        camera = await Camera.prisma().find_unique_or_raise(
            where={
                'id': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
        include: Optional[types.CameraInclude] = None,
        order: Optional[Union[types.CameraOrderByInput, List[types.CameraOrderByInput]]] = None,
        distinct: Optional[List[types.CameraScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Camera records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Camera records returned
        skip
            Ignore the first N results
        where
            Camera filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Camera model
        order
            Order the returned Camera records by any field
        distinct
            Filter Camera records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Camera]
            The list of all Camera records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Camera records
        cameras = await Camera.prisma().find_many(take=10)

        # find the first 5 Camera records ordered by the liveUrl field
        cameras = await Camera.prisma().find_many(
            take=5,
            order={
                'liveUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
        include: Optional[types.CameraInclude] = None,
        order: Optional[Union[types.CameraOrderByInput, List[types.CameraOrderByInput]]] = None,
        distinct: Optional[List[types.CameraScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Camera record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Camera filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Camera model
        order
            Order the returned Camera records by any field
        distinct
            Filter Camera records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Camera
            The first Camera record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Camera record ordered by the geo field
        camera = await Camera.prisma().find_first(
            skip=1,
            order={
                'geo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
        include: Optional[types.CameraInclude] = None,
        order: Optional[Union[types.CameraOrderByInput, List[types.CameraOrderByInput]]] = None,
        distinct: Optional[List[types.CameraScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Camera record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Camera filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Camera model
        order
            Order the returned Camera records by any field
        distinct
            Filter Camera records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Camera
            The first Camera record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Camera record ordered by the description field
        camera = await Camera.prisma().find_first_or_raise(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CameraUpdateInput,
        where: types.CameraWhereUniqueInput,
        include: Optional[types.CameraInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Camera record.

        Parameters
        ----------
        data
            Camera record data specifying what to update
        where
            Camera filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The updated Camera record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        camera = await Camera.prisma().update(
            where={
                'id': 'bigibebcib',
            },
            data={
                # data to update the Camera record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CameraWhereUniqueInput,
        data: types.CameraUpsertInput,
        include: Optional[types.CameraInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Camera filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Camera model

        Returns
        -------
        prisma.models.Camera
            The created or updated Camera record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        camera = await Camera.prisma().upsert(
            where={
                'id': 'bigaiehgcc',
            },
            data={
                'create': {
                    'id': 'bigaiehgcc',
                    'name': 'heejgedji',
                    'liveUrl': 'bjgjgibgbf',
                    'geo': 'bbbgbhfjge',
                    'location': Base64.encode(b'igbehcbab'),
                },
                'update': {
                    'name': 'heejgedji',
                    'liveUrl': 'bjgjgibgbf',
                    'geo': 'bbbgbhfjge',
                    'location': Base64.encode(b'igbehcbab'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CameraUpdateManyMutationInput,
        where: types.CameraWhereInput,
    ) -> int:
        """Update multiple Camera records

        Parameters
        ----------
        data
            Camera data to update the selected Camera records to
        where
            Filter to select the Camera records to update

        Returns
        -------
        int
            The total number of Camera records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Camera records
        total = await Camera.prisma().update_many(
            data={
                'location': Base64.encode(b'beeifcbebf')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Camera records present in the database

        Parameters
        ----------
        select
            Select the Camera fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Camera filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CameraCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Camera.prisma().count()

        # results: prisma.types.CameraCountAggregateOutput
        results = await Camera.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CameraCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
    ) -> types.CameraCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CameraCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CameraWhereInput] = None,
        cursor: Optional[types.CameraWhereUniqueInput] = None,
    ) -> Union[int, types.CameraCountAggregateOutput]:
        """Count the number of Camera records present in the database

        Parameters
        ----------
        select
            Select the Camera fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Camera filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CameraCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Camera.prisma().count()

        # results: prisma.types.CameraCountAggregateOutput
        results = await Camera.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CameraCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CameraWhereInput] = None
    ) -> int:
        """Delete multiple Camera records.

        Parameters
        ----------
        where
            Optional Camera filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Camera records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Camera records
        total = await Camera.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CameraScalarFieldKeys'],
        *,
        where: Optional['types.CameraWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CameraAvgAggregateInput'] = None,
        sum: Optional['types.CameraSumAggregateInput'] = None,
        min: Optional['types.CameraMinAggregateInput'] = None,
        max: Optional['types.CameraMaxAggregateInput'] = None,
        having: Optional['types.CameraScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CameraCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CameraScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CameraScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CameraGroupByOutput']:
        """Group Camera records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Camera fields to group records by
        where
            Camera filter to select records
        take
            Limit the maximum number of Camera records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CameraGroupByOutput]
            A list of dictionaries representing the Camera record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Camera records by liveUrl values
        # and count how many records are in each group
        results = await Camera.prisma().group_by(
            ['liveUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EffectivenessActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Effectiveness]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Effectiveness.prisma().query_raw(
            'SELECT * FROM Effectiveness WHERE id = $1',
            'bgcigfahea',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Effectiveness
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Effectiveness.prisma().query_first(
            'SELECT * FROM Effectiveness WHERE measureId = $1',
            'bcejgaggif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EffectivenessCreateInput,
        include: Optional[types.EffectivenessInclude] = None
    ) -> _PrismaModelT:
        """Create a new Effectiveness record.

        Parameters
        ----------
        data
            Effectiveness record data
        include
            Specifies which relations should be loaded on the returned Effectiveness model

        Returns
        -------
        prisma.models.Effectiveness
            The created Effectiveness record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Effectiveness record from just the required fields
        effectiveness = await Effectiveness.prisma().create(
            data={
                # data to create a Effectiveness record
                'measureId': 'idfjadbcc',
                'before': Json({'hgdhbjhhj': True}),
                'after': Json({'ecjjjfbae': True}),
                'effectivenessScore': 1775811865.89314,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EffectivenessCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Effectiveness records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Effectiveness record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Effectiveness.prisma().create_many(
            data=[
                {
                    # data to create a Effectiveness record
                    'measureId': 'jjfeafhfj',
                    'before': Json({'cbachdgfce': True}),
                    'after': Json({'chbfcacbd': True}),
                    'effectivenessScore': 456633834.205825,
                },
                {
                    # data to create a Effectiveness record
                    'measureId': 'bfidgijfjc',
                    'before': Json({'ihieecagf': True}),
                    'after': Json({'bghfciaafe': True}),
                    'effectivenessScore': 1627576247.205480,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EffectivenessWhereUniqueInput,
        include: Optional[types.EffectivenessInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Effectiveness record.

        Parameters
        ----------
        where
            Effectiveness filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Effectiveness model

        Returns
        -------
        prisma.models.Effectiveness
            The deleted Effectiveness record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        effectiveness = await Effectiveness.prisma().delete(
            where={
                'id': 'gaddfhfh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EffectivenessWhereUniqueInput,
        include: Optional[types.EffectivenessInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Effectiveness record.

        Parameters
        ----------
        where
            Effectiveness filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Effectiveness model

        Returns
        -------
        prisma.models.Effectiveness
            The found Effectiveness record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        effectiveness = await Effectiveness.prisma().find_unique(
            where={
                'id': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EffectivenessWhereUniqueInput,
        include: Optional[types.EffectivenessInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Effectiveness record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Effectiveness filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Effectiveness model

        Returns
        -------
        prisma.models.Effectiveness
            The found Effectiveness record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        effectiveness = await Effectiveness.prisma().find_unique_or_raise(
            where={
                'id': 'bgcffadich',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EffectivenessWhereInput] = None,
        cursor: Optional[types.EffectivenessWhereUniqueInput] = None,
        include: Optional[types.EffectivenessInclude] = None,
        order: Optional[Union[types.EffectivenessOrderByInput, List[types.EffectivenessOrderByInput]]] = None,
        distinct: Optional[List[types.EffectivenessScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Effectiveness records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Effectiveness records returned
        skip
            Ignore the first N results
        where
            Effectiveness filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Effectiveness model
        order
            Order the returned Effectiveness records by any field
        distinct
            Filter Effectiveness records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Effectiveness]
            The list of all Effectiveness records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Effectiveness records
        effectiveness = await Effectiveness.prisma().find_many(take=10)

        # find the first 5 Effectiveness records ordered by the before field
        effectiveness = await Effectiveness.prisma().find_many(
            take=5,
            order={
                'before': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EffectivenessWhereInput] = None,
        cursor: Optional[types.EffectivenessWhereUniqueInput] = None,
        include: Optional[types.EffectivenessInclude] = None,
        order: Optional[Union[types.EffectivenessOrderByInput, List[types.EffectivenessOrderByInput]]] = None,
        distinct: Optional[List[types.EffectivenessScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Effectiveness record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Effectiveness filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Effectiveness model
        order
            Order the returned Effectiveness records by any field
        distinct
            Filter Effectiveness records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Effectiveness
            The first Effectiveness record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Effectiveness record ordered by the after field
        effectiveness = await Effectiveness.prisma().find_first(
            skip=1,
            order={
                'after': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EffectivenessWhereInput] = None,
        cursor: Optional[types.EffectivenessWhereUniqueInput] = None,
        include: Optional[types.EffectivenessInclude] = None,
        order: Optional[Union[types.EffectivenessOrderByInput, List[types.EffectivenessOrderByInput]]] = None,
        distinct: Optional[List[types.EffectivenessScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Effectiveness record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Effectiveness filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Effectiveness model
        order
            Order the returned Effectiveness records by any field
        distinct
            Filter Effectiveness records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Effectiveness
            The first Effectiveness record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Effectiveness record ordered by the effectivenessScore field
        effectiveness = await Effectiveness.prisma().find_first_or_raise(
            skip=1,
            order={
                'effectivenessScore': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EffectivenessUpdateInput,
        where: types.EffectivenessWhereUniqueInput,
        include: Optional[types.EffectivenessInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Effectiveness record.

        Parameters
        ----------
        data
            Effectiveness record data specifying what to update
        where
            Effectiveness filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Effectiveness model

        Returns
        -------
        prisma.models.Effectiveness
            The updated Effectiveness record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        effectiveness = await Effectiveness.prisma().update(
            where={
                'id': 'fcbichhci',
            },
            data={
                # data to update the Effectiveness record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EffectivenessWhereUniqueInput,
        data: types.EffectivenessUpsertInput,
        include: Optional[types.EffectivenessInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Effectiveness filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Effectiveness model

        Returns
        -------
        prisma.models.Effectiveness
            The created or updated Effectiveness record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        effectiveness = await Effectiveness.prisma().upsert(
            where={
                'id': 'bcggadccgf',
            },
            data={
                'create': {
                    'id': 'bcggadccgf',
                    'measureId': 'bfidgijfjc',
                    'before': Json({'ihieecagf': True}),
                    'after': Json({'bghfciaafe': True}),
                    'effectivenessScore': 1627576247.205480,
                },
                'update': {
                    'measureId': 'bfidgijfjc',
                    'before': Json({'ihieecagf': True}),
                    'after': Json({'bghfciaafe': True}),
                    'effectivenessScore': 1627576247.205480,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EffectivenessUpdateManyMutationInput,
        where: types.EffectivenessWhereInput,
    ) -> int:
        """Update multiple Effectiveness records

        Parameters
        ----------
        data
            Effectiveness data to update the selected Effectiveness records to
        where
            Filter to select the Effectiveness records to update

        Returns
        -------
        int
            The total number of Effectiveness records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Effectiveness records
        total = await Effectiveness.prisma().update_many(
            data={
                'id': 'jdcfdcgc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EffectivenessWhereInput] = None,
        cursor: Optional[types.EffectivenessWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Effectiveness records present in the database

        Parameters
        ----------
        select
            Select the Effectiveness fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Effectiveness filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EffectivenessCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Effectiveness.prisma().count()

        # results: prisma.types.EffectivenessCountAggregateOutput
        results = await Effectiveness.prisma().count(
            select={
                '_all': True,
                'measureId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EffectivenessCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EffectivenessWhereInput] = None,
        cursor: Optional[types.EffectivenessWhereUniqueInput] = None,
    ) -> types.EffectivenessCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EffectivenessCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EffectivenessWhereInput] = None,
        cursor: Optional[types.EffectivenessWhereUniqueInput] = None,
    ) -> Union[int, types.EffectivenessCountAggregateOutput]:
        """Count the number of Effectiveness records present in the database

        Parameters
        ----------
        select
            Select the Effectiveness fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Effectiveness filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EffectivenessCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Effectiveness.prisma().count()

        # results: prisma.types.EffectivenessCountAggregateOutput
        results = await Effectiveness.prisma().count(
            select={
                '_all': True,
                'before': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EffectivenessCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EffectivenessWhereInput] = None
    ) -> int:
        """Delete multiple Effectiveness records.

        Parameters
        ----------
        where
            Optional Effectiveness filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Effectiveness records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Effectiveness records
        total = await Effectiveness.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EffectivenessScalarFieldKeys'],
        *,
        where: Optional['types.EffectivenessWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EffectivenessAvgAggregateInput'] = None,
        sum: Optional['types.EffectivenessSumAggregateInput'] = None,
        min: Optional['types.EffectivenessMinAggregateInput'] = None,
        max: Optional['types.EffectivenessMaxAggregateInput'] = None,
        having: Optional['types.EffectivenessScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EffectivenessCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EffectivenessScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EffectivenessScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EffectivenessGroupByOutput']:
        """Group Effectiveness records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Effectiveness fields to group records by
        where
            Effectiveness filter to select records
        take
            Limit the maximum number of Effectiveness records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EffectivenessGroupByOutput]
            A list of dictionaries representing the Effectiveness record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Effectiveness records by after values
        # and count how many records are in each group
        results = await Effectiveness.prisma().group_by(
            ['after'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EnvironmentalDataActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EnvironmentalData]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EnvironmentalData.prisma().query_raw(
            'SELECT * FROM EnvironmentalData WHERE id = $1',
            'cafdaehjid',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EnvironmentalData
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EnvironmentalData.prisma().query_first(
            'SELECT * FROM EnvironmentalData WHERE timestamp = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EnvironmentalDataCreateInput,
        include: Optional[types.EnvironmentalDataInclude] = None
    ) -> _PrismaModelT:
        """Create a new EnvironmentalData record.

        Parameters
        ----------
        data
            EnvironmentalData record data
        include
            Specifies which relations should be loaded on the returned EnvironmentalData model

        Returns
        -------
        prisma.models.EnvironmentalData
            The created EnvironmentalData record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EnvironmentalData record from just the required fields
        environmentaldata = await EnvironmentalData.prisma().create(
            data={
                # data to create a EnvironmentalData record
                'timestamp': datetime.datetime.utcnow(),
                'location': Base64.encode(b'gifdddbia'),
                'emissionLevel': 127474245.94892,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EnvironmentalDataCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EnvironmentalData records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EnvironmentalData record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EnvironmentalData.prisma().create_many(
            data=[
                {
                    # data to create a EnvironmentalData record
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bjgejjabff'),
                    'emissionLevel': 1228891816.25520,
                },
                {
                    # data to create a EnvironmentalData record
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bccdfhdigc'),
                    'emissionLevel': 541269159.106484,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EnvironmentalDataWhereUniqueInput,
        include: Optional[types.EnvironmentalDataInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EnvironmentalData record.

        Parameters
        ----------
        where
            EnvironmentalData filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EnvironmentalData model

        Returns
        -------
        prisma.models.EnvironmentalData
            The deleted EnvironmentalData record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        environmentaldata = await EnvironmentalData.prisma().delete(
            where={
                'id': 'faidicegb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EnvironmentalDataWhereUniqueInput,
        include: Optional[types.EnvironmentalDataInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EnvironmentalData record.

        Parameters
        ----------
        where
            EnvironmentalData filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EnvironmentalData model

        Returns
        -------
        prisma.models.EnvironmentalData
            The found EnvironmentalData record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        environmentaldata = await EnvironmentalData.prisma().find_unique(
            where={
                'id': 'bacecgfhbe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EnvironmentalDataWhereUniqueInput,
        include: Optional[types.EnvironmentalDataInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EnvironmentalData record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EnvironmentalData filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EnvironmentalData model

        Returns
        -------
        prisma.models.EnvironmentalData
            The found EnvironmentalData record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        environmentaldata = await EnvironmentalData.prisma().find_unique_or_raise(
            where={
                'id': 'ihcahiead',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EnvironmentalDataWhereInput] = None,
        cursor: Optional[types.EnvironmentalDataWhereUniqueInput] = None,
        include: Optional[types.EnvironmentalDataInclude] = None,
        order: Optional[Union[types.EnvironmentalDataOrderByInput, List[types.EnvironmentalDataOrderByInput]]] = None,
        distinct: Optional[List[types.EnvironmentalDataScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EnvironmentalData records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EnvironmentalData records returned
        skip
            Ignore the first N results
        where
            EnvironmentalData filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EnvironmentalData model
        order
            Order the returned EnvironmentalData records by any field
        distinct
            Filter EnvironmentalData records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EnvironmentalData]
            The list of all EnvironmentalData records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EnvironmentalData records
        environmentaldatas = await EnvironmentalData.prisma().find_many(take=10)

        # find the first 5 EnvironmentalData records ordered by the location field
        environmentaldatas = await EnvironmentalData.prisma().find_many(
            take=5,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EnvironmentalDataWhereInput] = None,
        cursor: Optional[types.EnvironmentalDataWhereUniqueInput] = None,
        include: Optional[types.EnvironmentalDataInclude] = None,
        order: Optional[Union[types.EnvironmentalDataOrderByInput, List[types.EnvironmentalDataOrderByInput]]] = None,
        distinct: Optional[List[types.EnvironmentalDataScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EnvironmentalData record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EnvironmentalData filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EnvironmentalData model
        order
            Order the returned EnvironmentalData records by any field
        distinct
            Filter EnvironmentalData records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EnvironmentalData
            The first EnvironmentalData record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EnvironmentalData record ordered by the emissionLevel field
        environmentaldata = await EnvironmentalData.prisma().find_first(
            skip=1,
            order={
                'emissionLevel': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EnvironmentalDataWhereInput] = None,
        cursor: Optional[types.EnvironmentalDataWhereUniqueInput] = None,
        include: Optional[types.EnvironmentalDataInclude] = None,
        order: Optional[Union[types.EnvironmentalDataOrderByInput, List[types.EnvironmentalDataOrderByInput]]] = None,
        distinct: Optional[List[types.EnvironmentalDataScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EnvironmentalData record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EnvironmentalData filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EnvironmentalData model
        order
            Order the returned EnvironmentalData records by any field
        distinct
            Filter EnvironmentalData records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EnvironmentalData
            The first EnvironmentalData record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EnvironmentalData record ordered by the id field
        environmentaldata = await EnvironmentalData.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EnvironmentalDataUpdateInput,
        where: types.EnvironmentalDataWhereUniqueInput,
        include: Optional[types.EnvironmentalDataInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EnvironmentalData record.

        Parameters
        ----------
        data
            EnvironmentalData record data specifying what to update
        where
            EnvironmentalData filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EnvironmentalData model

        Returns
        -------
        prisma.models.EnvironmentalData
            The updated EnvironmentalData record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        environmentaldata = await EnvironmentalData.prisma().update(
            where={
                'id': 'biheheiajg',
            },
            data={
                # data to update the EnvironmentalData record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EnvironmentalDataWhereUniqueInput,
        data: types.EnvironmentalDataUpsertInput,
        include: Optional[types.EnvironmentalDataInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EnvironmentalData filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EnvironmentalData model

        Returns
        -------
        prisma.models.EnvironmentalData
            The created or updated EnvironmentalData record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        environmentaldata = await EnvironmentalData.prisma().upsert(
            where={
                'id': 'jbgijghgb',
            },
            data={
                'create': {
                    'id': 'jbgijghgb',
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bccdfhdigc'),
                    'emissionLevel': 541269159.106484,
                },
                'update': {
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bccdfhdigc'),
                    'emissionLevel': 541269159.106484,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EnvironmentalDataUpdateManyMutationInput,
        where: types.EnvironmentalDataWhereInput,
    ) -> int:
        """Update multiple EnvironmentalData records

        Parameters
        ----------
        data
            EnvironmentalData data to update the selected EnvironmentalData records to
        where
            Filter to select the EnvironmentalData records to update

        Returns
        -------
        int
            The total number of EnvironmentalData records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EnvironmentalData records
        total = await EnvironmentalData.prisma().update_many(
            data={
                'timestamp': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EnvironmentalDataWhereInput] = None,
        cursor: Optional[types.EnvironmentalDataWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EnvironmentalData records present in the database

        Parameters
        ----------
        select
            Select the EnvironmentalData fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EnvironmentalData filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EnvironmentalDataCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EnvironmentalData.prisma().count()

        # results: prisma.types.EnvironmentalDataCountAggregateOutput
        results = await EnvironmentalData.prisma().count(
            select={
                '_all': True,
                'location': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EnvironmentalDataCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EnvironmentalDataWhereInput] = None,
        cursor: Optional[types.EnvironmentalDataWhereUniqueInput] = None,
    ) -> types.EnvironmentalDataCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EnvironmentalDataCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EnvironmentalDataWhereInput] = None,
        cursor: Optional[types.EnvironmentalDataWhereUniqueInput] = None,
    ) -> Union[int, types.EnvironmentalDataCountAggregateOutput]:
        """Count the number of EnvironmentalData records present in the database

        Parameters
        ----------
        select
            Select the EnvironmentalData fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EnvironmentalData filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EnvironmentalDataCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EnvironmentalData.prisma().count()

        # results: prisma.types.EnvironmentalDataCountAggregateOutput
        results = await EnvironmentalData.prisma().count(
            select={
                '_all': True,
                'emissionLevel': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EnvironmentalDataCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EnvironmentalDataWhereInput] = None
    ) -> int:
        """Delete multiple EnvironmentalData records.

        Parameters
        ----------
        where
            Optional EnvironmentalData filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EnvironmentalData records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EnvironmentalData records
        total = await EnvironmentalData.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EnvironmentalDataScalarFieldKeys'],
        *,
        where: Optional['types.EnvironmentalDataWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EnvironmentalDataAvgAggregateInput'] = None,
        sum: Optional['types.EnvironmentalDataSumAggregateInput'] = None,
        min: Optional['types.EnvironmentalDataMinAggregateInput'] = None,
        max: Optional['types.EnvironmentalDataMaxAggregateInput'] = None,
        having: Optional['types.EnvironmentalDataScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EnvironmentalDataCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EnvironmentalDataScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EnvironmentalDataScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EnvironmentalDataGroupByOutput']:
        """Group EnvironmentalData records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EnvironmentalData fields to group records by
        where
            EnvironmentalData filter to select records
        take
            Limit the maximum number of EnvironmentalData records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EnvironmentalDataGroupByOutput]
            A list of dictionaries representing the EnvironmentalData record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EnvironmentalData records by id values
        # and count how many records are in each group
        results = await EnvironmentalData.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EventActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Event]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Event.prisma().query_raw(
            'SELECT * FROM Event WHERE id = $1',
            'hgjcghfbi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Event
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Event.prisma().query_first(
            'SELECT * FROM Event WHERE name = $1',
            'icadbcehj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EventCreateInput,
        include: Optional[types.EventInclude] = None
    ) -> _PrismaModelT:
        """Create a new Event record.

        Parameters
        ----------
        data
            Event record data
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The created Event record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Event record from just the required fields
        event = await Event.prisma().create(
            data={
                # data to create a Event record
                'name': 'jchciaee',
                'date': datetime.datetime.utcnow(),
                'location': Base64.encode(b'deeificjd'),
                'impactLevel': 1121741130,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EventCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Event records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Event record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Event.prisma().create_many(
            data=[
                {
                    # data to create a Event record
                    'name': 'bejfijgcfb',
                    'date': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'caifcbgii'),
                    'impactLevel': 860811569,
                },
                {
                    # data to create a Event record
                    'name': 'bggajdcbbi',
                    'date': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'fcfhgbjed'),
                    'impactLevel': 736209796,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EventWhereUniqueInput,
        include: Optional[types.EventInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Event record.

        Parameters
        ----------
        where
            Event filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The deleted Event record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event = await Event.prisma().delete(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EventWhereUniqueInput,
        include: Optional[types.EventInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Event record.

        Parameters
        ----------
        where
            Event filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The found Event record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event = await Event.prisma().find_unique(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EventWhereUniqueInput,
        include: Optional[types.EventInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Event record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Event filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The found Event record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event = await Event.prisma().find_unique_or_raise(
            where={
                'id': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
        include: Optional[types.EventInclude] = None,
        order: Optional[Union[types.EventOrderByInput, List[types.EventOrderByInput]]] = None,
        distinct: Optional[List[types.EventScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Event records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Event records returned
        skip
            Ignore the first N results
        where
            Event filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Event model
        order
            Order the returned Event records by any field
        distinct
            Filter Event records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Event]
            The list of all Event records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Event records
        events = await Event.prisma().find_many(take=10)

        # find the first 5 Event records ordered by the date field
        events = await Event.prisma().find_many(
            take=5,
            order={
                'date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
        include: Optional[types.EventInclude] = None,
        order: Optional[Union[types.EventOrderByInput, List[types.EventOrderByInput]]] = None,
        distinct: Optional[List[types.EventScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Event record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Event filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Event model
        order
            Order the returned Event records by any field
        distinct
            Filter Event records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Event
            The first Event record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Event record ordered by the location field
        event = await Event.prisma().find_first(
            skip=1,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
        include: Optional[types.EventInclude] = None,
        order: Optional[Union[types.EventOrderByInput, List[types.EventOrderByInput]]] = None,
        distinct: Optional[List[types.EventScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Event record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Event filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Event model
        order
            Order the returned Event records by any field
        distinct
            Filter Event records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Event
            The first Event record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Event record ordered by the impactLevel field
        event = await Event.prisma().find_first_or_raise(
            skip=1,
            order={
                'impactLevel': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EventUpdateInput,
        where: types.EventWhereUniqueInput,
        include: Optional[types.EventInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Event record.

        Parameters
        ----------
        data
            Event record data specifying what to update
        where
            Event filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The updated Event record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        event = await Event.prisma().update(
            where={
                'id': 'bjafcgbffc',
            },
            data={
                # data to update the Event record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EventWhereUniqueInput,
        data: types.EventUpsertInput,
        include: Optional[types.EventInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Event filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The created or updated Event record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event = await Event.prisma().upsert(
            where={
                'id': 'hihegjif',
            },
            data={
                'create': {
                    'id': 'hihegjif',
                    'name': 'bggajdcbbi',
                    'date': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'fcfhgbjed'),
                    'impactLevel': 736209796,
                },
                'update': {
                    'name': 'bggajdcbbi',
                    'date': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'fcfhgbjed'),
                    'impactLevel': 736209796,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EventUpdateManyMutationInput,
        where: types.EventWhereInput,
    ) -> int:
        """Update multiple Event records

        Parameters
        ----------
        data
            Event data to update the selected Event records to
        where
            Filter to select the Event records to update

        Returns
        -------
        int
            The total number of Event records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Event records
        total = await Event.prisma().update_many(
            data={
                'id': 'bdjidcidac'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Event records present in the database

        Parameters
        ----------
        select
            Select the Event fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Event filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EventCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Event.prisma().count()

        # results: prisma.types.EventCountAggregateOutput
        results = await Event.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EventCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
    ) -> types.EventCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EventCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
    ) -> Union[int, types.EventCountAggregateOutput]:
        """Count the number of Event records present in the database

        Parameters
        ----------
        select
            Select the Event fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Event filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EventCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Event.prisma().count()

        # results: prisma.types.EventCountAggregateOutput
        results = await Event.prisma().count(
            select={
                '_all': True,
                'date': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EventCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EventWhereInput] = None
    ) -> int:
        """Delete multiple Event records.

        Parameters
        ----------
        where
            Optional Event filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Event records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Event records
        total = await Event.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EventScalarFieldKeys'],
        *,
        where: Optional['types.EventWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EventAvgAggregateInput'] = None,
        sum: Optional['types.EventSumAggregateInput'] = None,
        min: Optional['types.EventMinAggregateInput'] = None,
        max: Optional['types.EventMaxAggregateInput'] = None,
        having: Optional['types.EventScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EventCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EventScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EventScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EventGroupByOutput']:
        """Group Event records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Event fields to group records by
        where
            Event filter to select records
        take
            Limit the maximum number of Event records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EventGroupByOutput]
            A list of dictionaries representing the Event record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Event records by location values
        # and count how many records are in each group
        results = await Event.prisma().group_by(
            ['location'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ForecastActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Forecast]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Forecast.prisma().query_raw(
            'SELECT * FROM Forecast WHERE id = $1',
            'ifgaaagff',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Forecast
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Forecast.prisma().query_first(
            'SELECT * FROM Forecast WHERE timestamp = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ForecastCreateInput,
        include: Optional[types.ForecastInclude] = None
    ) -> _PrismaModelT:
        """Create a new Forecast record.

        Parameters
        ----------
        data
            Forecast record data
        include
            Specifies which relations should be loaded on the returned Forecast model

        Returns
        -------
        prisma.models.Forecast
            The created Forecast record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Forecast record from just the required fields
        forecast = await Forecast.prisma().create(
            data={
                # data to create a Forecast record
                'timestamp': datetime.datetime.utcnow(),
                'location': Base64.encode(b'befcddgjce'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ForecastCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Forecast records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Forecast record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Forecast.prisma().create_many(
            data=[
                {
                    # data to create a Forecast record
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bfhdbjjgfd'),
                },
                {
                    # data to create a Forecast record
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'cabdjadaji'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ForecastWhereUniqueInput,
        include: Optional[types.ForecastInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Forecast record.

        Parameters
        ----------
        where
            Forecast filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Forecast model

        Returns
        -------
        prisma.models.Forecast
            The deleted Forecast record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forecast = await Forecast.prisma().delete(
            where={
                'id': 'faajgfadf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ForecastWhereUniqueInput,
        include: Optional[types.ForecastInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Forecast record.

        Parameters
        ----------
        where
            Forecast filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Forecast model

        Returns
        -------
        prisma.models.Forecast
            The found Forecast record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forecast = await Forecast.prisma().find_unique(
            where={
                'id': 'biaagcedjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ForecastWhereUniqueInput,
        include: Optional[types.ForecastInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Forecast record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Forecast filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Forecast model

        Returns
        -------
        prisma.models.Forecast
            The found Forecast record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forecast = await Forecast.prisma().find_unique_or_raise(
            where={
                'id': 'cahhaghecf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForecastWhereInput] = None,
        cursor: Optional[types.ForecastWhereUniqueInput] = None,
        include: Optional[types.ForecastInclude] = None,
        order: Optional[Union[types.ForecastOrderByInput, List[types.ForecastOrderByInput]]] = None,
        distinct: Optional[List[types.ForecastScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Forecast records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Forecast records returned
        skip
            Ignore the first N results
        where
            Forecast filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Forecast model
        order
            Order the returned Forecast records by any field
        distinct
            Filter Forecast records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Forecast]
            The list of all Forecast records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Forecast records
        forecasts = await Forecast.prisma().find_many(take=10)

        # find the first 5 Forecast records ordered by the location field
        forecasts = await Forecast.prisma().find_many(
            take=5,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForecastWhereInput] = None,
        cursor: Optional[types.ForecastWhereUniqueInput] = None,
        include: Optional[types.ForecastInclude] = None,
        order: Optional[Union[types.ForecastOrderByInput, List[types.ForecastOrderByInput]]] = None,
        distinct: Optional[List[types.ForecastScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Forecast record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Forecast filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Forecast model
        order
            Order the returned Forecast records by any field
        distinct
            Filter Forecast records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Forecast
            The first Forecast record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Forecast record ordered by the predictedDensity field
        forecast = await Forecast.prisma().find_first(
            skip=1,
            order={
                'predictedDensity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ForecastWhereInput] = None,
        cursor: Optional[types.ForecastWhereUniqueInput] = None,
        include: Optional[types.ForecastInclude] = None,
        order: Optional[Union[types.ForecastOrderByInput, List[types.ForecastOrderByInput]]] = None,
        distinct: Optional[List[types.ForecastScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Forecast record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Forecast filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Forecast model
        order
            Order the returned Forecast records by any field
        distinct
            Filter Forecast records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Forecast
            The first Forecast record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Forecast record ordered by the predictedSpeed field
        forecast = await Forecast.prisma().find_first_or_raise(
            skip=1,
            order={
                'predictedSpeed': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ForecastUpdateInput,
        where: types.ForecastWhereUniqueInput,
        include: Optional[types.ForecastInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Forecast record.

        Parameters
        ----------
        data
            Forecast record data specifying what to update
        where
            Forecast filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Forecast model

        Returns
        -------
        prisma.models.Forecast
            The updated Forecast record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        forecast = await Forecast.prisma().update(
            where={
                'id': 'bghcbbcidi',
            },
            data={
                # data to update the Forecast record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ForecastWhereUniqueInput,
        data: types.ForecastUpsertInput,
        include: Optional[types.ForecastInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Forecast filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Forecast model

        Returns
        -------
        prisma.models.Forecast
            The created or updated Forecast record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        forecast = await Forecast.prisma().upsert(
            where={
                'id': 'jcgghhgdj',
            },
            data={
                'create': {
                    'id': 'jcgghhgdj',
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'cabdjadaji'),
                },
                'update': {
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'cabdjadaji'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ForecastUpdateManyMutationInput,
        where: types.ForecastWhereInput,
    ) -> int:
        """Update multiple Forecast records

        Parameters
        ----------
        data
            Forecast data to update the selected Forecast records to
        where
            Filter to select the Forecast records to update

        Returns
        -------
        int
            The total number of Forecast records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Forecast records
        total = await Forecast.prisma().update_many(
            data={
                'id': 'beehgcebbg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForecastWhereInput] = None,
        cursor: Optional[types.ForecastWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Forecast records present in the database

        Parameters
        ----------
        select
            Select the Forecast fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Forecast filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForecastCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Forecast.prisma().count()

        # results: prisma.types.ForecastCountAggregateOutput
        results = await Forecast.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ForecastCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForecastWhereInput] = None,
        cursor: Optional[types.ForecastWhereUniqueInput] = None,
    ) -> types.ForecastCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ForecastCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ForecastWhereInput] = None,
        cursor: Optional[types.ForecastWhereUniqueInput] = None,
    ) -> Union[int, types.ForecastCountAggregateOutput]:
        """Count the number of Forecast records present in the database

        Parameters
        ----------
        select
            Select the Forecast fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Forecast filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ForecastCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Forecast.prisma().count()

        # results: prisma.types.ForecastCountAggregateOutput
        results = await Forecast.prisma().count(
            select={
                '_all': True,
                'location': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ForecastCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ForecastWhereInput] = None
    ) -> int:
        """Delete multiple Forecast records.

        Parameters
        ----------
        where
            Optional Forecast filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Forecast records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Forecast records
        total = await Forecast.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ForecastScalarFieldKeys'],
        *,
        where: Optional['types.ForecastWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ForecastAvgAggregateInput'] = None,
        sum: Optional['types.ForecastSumAggregateInput'] = None,
        min: Optional['types.ForecastMinAggregateInput'] = None,
        max: Optional['types.ForecastMaxAggregateInput'] = None,
        having: Optional['types.ForecastScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ForecastCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ForecastScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ForecastScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ForecastGroupByOutput']:
        """Group Forecast records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Forecast fields to group records by
        where
            Forecast filter to select records
        take
            Limit the maximum number of Forecast records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ForecastGroupByOutput]
            A list of dictionaries representing the Forecast record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Forecast records by predictedDensity values
        # and count how many records are in each group
        results = await Forecast.prisma().group_by(
            ['predictedDensity'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class IncidentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Incident]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Incident.prisma().query_raw(
            'SELECT * FROM Incident WHERE id = $1',
            'bhdiaidiaf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Incident
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Incident.prisma().query_first(
            'SELECT * FROM Incident WHERE description = $1',
            'deajegcfi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.IncidentCreateInput,
        include: Optional[types.IncidentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Incident record.

        Parameters
        ----------
        data
            Incident record data
        include
            Specifies which relations should be loaded on the returned Incident model

        Returns
        -------
        prisma.models.Incident
            The created Incident record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Incident record from just the required fields
        incident = await Incident.prisma().create(
            data={
                # data to create a Incident record
                'description': 'gabahhhjf',
                'severity': 290603296,
                'timestamp': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.IncidentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Incident records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Incident record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Incident.prisma().create_many(
            data=[
                {
                    # data to create a Incident record
                    'description': 'bifficggej',
                    'severity': 1611009182,
                    'timestamp': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Incident record
                    'description': 'eegghdhjb',
                    'severity': 300568396,
                    'timestamp': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.IncidentWhereUniqueInput,
        include: Optional[types.IncidentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Incident record.

        Parameters
        ----------
        where
            Incident filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Incident model

        Returns
        -------
        prisma.models.Incident
            The deleted Incident record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        incident = await Incident.prisma().delete(
            where={
                'id': 'gdcgcgagj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.IncidentWhereUniqueInput,
        include: Optional[types.IncidentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Incident record.

        Parameters
        ----------
        where
            Incident filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Incident model

        Returns
        -------
        prisma.models.Incident
            The found Incident record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        incident = await Incident.prisma().find_unique(
            where={
                'id': 'bhceabbgja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.IncidentWhereUniqueInput,
        include: Optional[types.IncidentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Incident record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Incident filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Incident model

        Returns
        -------
        prisma.models.Incident
            The found Incident record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        incident = await Incident.prisma().find_unique_or_raise(
            where={
                'id': 'ehabfhegh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.IncidentWhereInput] = None,
        cursor: Optional[types.IncidentWhereUniqueInput] = None,
        include: Optional[types.IncidentInclude] = None,
        order: Optional[Union[types.IncidentOrderByInput, List[types.IncidentOrderByInput]]] = None,
        distinct: Optional[List[types.IncidentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Incident records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Incident records returned
        skip
            Ignore the first N results
        where
            Incident filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Incident model
        order
            Order the returned Incident records by any field
        distinct
            Filter Incident records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Incident]
            The list of all Incident records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Incident records
        incidents = await Incident.prisma().find_many(take=10)

        # find the first 5 Incident records ordered by the severity field
        incidents = await Incident.prisma().find_many(
            take=5,
            order={
                'severity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.IncidentWhereInput] = None,
        cursor: Optional[types.IncidentWhereUniqueInput] = None,
        include: Optional[types.IncidentInclude] = None,
        order: Optional[Union[types.IncidentOrderByInput, List[types.IncidentOrderByInput]]] = None,
        distinct: Optional[List[types.IncidentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Incident record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Incident filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Incident model
        order
            Order the returned Incident records by any field
        distinct
            Filter Incident records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Incident
            The first Incident record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Incident record ordered by the timestamp field
        incident = await Incident.prisma().find_first(
            skip=1,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.IncidentWhereInput] = None,
        cursor: Optional[types.IncidentWhereUniqueInput] = None,
        include: Optional[types.IncidentInclude] = None,
        order: Optional[Union[types.IncidentOrderByInput, List[types.IncidentOrderByInput]]] = None,
        distinct: Optional[List[types.IncidentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Incident record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Incident filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Incident model
        order
            Order the returned Incident records by any field
        distinct
            Filter Incident records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Incident
            The first Incident record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Incident record ordered by the location field
        incident = await Incident.prisma().find_first_or_raise(
            skip=1,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.IncidentUpdateInput,
        where: types.IncidentWhereUniqueInput,
        include: Optional[types.IncidentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Incident record.

        Parameters
        ----------
        data
            Incident record data specifying what to update
        where
            Incident filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Incident model

        Returns
        -------
        prisma.models.Incident
            The updated Incident record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        incident = await Incident.prisma().update(
            where={
                'id': 'bcajcajjbc',
            },
            data={
                # data to update the Incident record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.IncidentWhereUniqueInput,
        data: types.IncidentUpsertInput,
        include: Optional[types.IncidentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Incident filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Incident model

        Returns
        -------
        prisma.models.Incident
            The created or updated Incident record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        incident = await Incident.prisma().upsert(
            where={
                'id': 'bfdgheeegf',
            },
            data={
                'create': {
                    'id': 'bfdgheeegf',
                    'description': 'eegghdhjb',
                    'severity': 300568396,
                    'timestamp': datetime.datetime.utcnow(),
                },
                'update': {
                    'description': 'eegghdhjb',
                    'severity': 300568396,
                    'timestamp': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.IncidentUpdateManyMutationInput,
        where: types.IncidentWhereInput,
    ) -> int:
        """Update multiple Incident records

        Parameters
        ----------
        data
            Incident data to update the selected Incident records to
        where
            Filter to select the Incident records to update

        Returns
        -------
        int
            The total number of Incident records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Incident records
        total = await Incident.prisma().update_many(
            data={
                'id': 'ececbijji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.IncidentWhereInput] = None,
        cursor: Optional[types.IncidentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Incident records present in the database

        Parameters
        ----------
        select
            Select the Incident fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Incident filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.IncidentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Incident.prisma().count()

        # results: prisma.types.IncidentCountAggregateOutput
        results = await Incident.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.IncidentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.IncidentWhereInput] = None,
        cursor: Optional[types.IncidentWhereUniqueInput] = None,
    ) -> types.IncidentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.IncidentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.IncidentWhereInput] = None,
        cursor: Optional[types.IncidentWhereUniqueInput] = None,
    ) -> Union[int, types.IncidentCountAggregateOutput]:
        """Count the number of Incident records present in the database

        Parameters
        ----------
        select
            Select the Incident fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Incident filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.IncidentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Incident.prisma().count()

        # results: prisma.types.IncidentCountAggregateOutput
        results = await Incident.prisma().count(
            select={
                '_all': True,
                'severity': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.IncidentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.IncidentWhereInput] = None
    ) -> int:
        """Delete multiple Incident records.

        Parameters
        ----------
        where
            Optional Incident filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Incident records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Incident records
        total = await Incident.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.IncidentScalarFieldKeys'],
        *,
        where: Optional['types.IncidentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.IncidentAvgAggregateInput'] = None,
        sum: Optional['types.IncidentSumAggregateInput'] = None,
        min: Optional['types.IncidentMinAggregateInput'] = None,
        max: Optional['types.IncidentMaxAggregateInput'] = None,
        having: Optional['types.IncidentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.IncidentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.IncidentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.IncidentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.IncidentGroupByOutput']:
        """Group Incident records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Incident fields to group records by
        where
            Incident filter to select records
        take
            Limit the maximum number of Incident records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.IncidentGroupByOutput]
            A list of dictionaries representing the Incident record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Incident records by timestamp values
        # and count how many records are in each group
        results = await Incident.prisma().group_by(
            ['timestamp'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Notification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Notification.prisma().query_raw(
            'SELECT * FROM Notification WHERE id = $1',
            'cbcfgdcdhf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Notification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Notification.prisma().query_first(
            'SELECT * FROM Notification WHERE timestamp = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'timestamp': datetime.datetime.utcnow(),
                'message': 'fdgjfbhia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'timestamp': datetime.datetime.utcnow(),
                    'message': 'jcehcdchh',
                },
                {
                    # data to create a Notification record
                    'timestamp': datetime.datetime.utcnow(),
                    'message': 'bgcbjdhjcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 'bieiidcabj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 'bjcbfcieaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 'cbaaechiej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the driverId field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'driverId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the message field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the id field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 'iejbeaaeg',
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 'jcibfcbhf',
            },
            data={
                'create': {
                    'id': 'jcibfcbhf',
                    'timestamp': datetime.datetime.utcnow(),
                    'message': 'bgcbjdhjcc',
                },
                'update': {
                    'timestamp': datetime.datetime.utcnow(),
                    'message': 'bgcbjdhjcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'timestamp': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'driverId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'message': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeys'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by id values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ScenarioActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Scenario]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Scenario.prisma().query_raw(
            'SELECT * FROM Scenario WHERE id = $1',
            'chdadcaga',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Scenario
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Scenario.prisma().query_first(
            'SELECT * FROM Scenario WHERE name = $1',
            'jicieifbh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ScenarioCreateInput,
        include: Optional[types.ScenarioInclude] = None
    ) -> _PrismaModelT:
        """Create a new Scenario record.

        Parameters
        ----------
        data
            Scenario record data
        include
            Specifies which relations should be loaded on the returned Scenario model

        Returns
        -------
        prisma.models.Scenario
            The created Scenario record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Scenario record from just the required fields
        scenario = await Scenario.prisma().create(
            data={
                # data to create a Scenario record
                'name': 'fbahdheji',
                'impactAssessment': Json({'cbbheiicgh': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ScenarioCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Scenario records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Scenario record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Scenario.prisma().create_many(
            data=[
                {
                    # data to create a Scenario record
                    'name': 'beabjeejdg',
                    'impactAssessment': Json({'bcjhgahffd': True}),
                },
                {
                    # data to create a Scenario record
                    'name': 'fbjeiiffa',
                    'impactAssessment': Json({'jhgidcgbf': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ScenarioWhereUniqueInput,
        include: Optional[types.ScenarioInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Scenario record.

        Parameters
        ----------
        where
            Scenario filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Scenario model

        Returns
        -------
        prisma.models.Scenario
            The deleted Scenario record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        scenario = await Scenario.prisma().delete(
            where={
                'id': 'bgjgecfejc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ScenarioWhereUniqueInput,
        include: Optional[types.ScenarioInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Scenario record.

        Parameters
        ----------
        where
            Scenario filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Scenario model

        Returns
        -------
        prisma.models.Scenario
            The found Scenario record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        scenario = await Scenario.prisma().find_unique(
            where={
                'id': 'bgjcgchib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ScenarioWhereUniqueInput,
        include: Optional[types.ScenarioInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Scenario record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Scenario filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Scenario model

        Returns
        -------
        prisma.models.Scenario
            The found Scenario record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        scenario = await Scenario.prisma().find_unique_or_raise(
            where={
                'id': 'bacdaibgfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScenarioWhereInput] = None,
        cursor: Optional[types.ScenarioWhereUniqueInput] = None,
        include: Optional[types.ScenarioInclude] = None,
        order: Optional[Union[types.ScenarioOrderByInput, List[types.ScenarioOrderByInput]]] = None,
        distinct: Optional[List[types.ScenarioScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Scenario records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Scenario records returned
        skip
            Ignore the first N results
        where
            Scenario filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Scenario model
        order
            Order the returned Scenario records by any field
        distinct
            Filter Scenario records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Scenario]
            The list of all Scenario records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Scenario records
        scenarios = await Scenario.prisma().find_many(take=10)

        # find the first 5 Scenario records ordered by the description field
        scenarios = await Scenario.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ScenarioWhereInput] = None,
        cursor: Optional[types.ScenarioWhereUniqueInput] = None,
        include: Optional[types.ScenarioInclude] = None,
        order: Optional[Union[types.ScenarioOrderByInput, List[types.ScenarioOrderByInput]]] = None,
        distinct: Optional[List[types.ScenarioScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Scenario record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Scenario filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Scenario model
        order
            Order the returned Scenario records by any field
        distinct
            Filter Scenario records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Scenario
            The first Scenario record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Scenario record ordered by the impactAssessment field
        scenario = await Scenario.prisma().find_first(
            skip=1,
            order={
                'impactAssessment': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ScenarioWhereInput] = None,
        cursor: Optional[types.ScenarioWhereUniqueInput] = None,
        include: Optional[types.ScenarioInclude] = None,
        order: Optional[Union[types.ScenarioOrderByInput, List[types.ScenarioOrderByInput]]] = None,
        distinct: Optional[List[types.ScenarioScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Scenario record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Scenario filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Scenario model
        order
            Order the returned Scenario records by any field
        distinct
            Filter Scenario records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Scenario
            The first Scenario record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Scenario record ordered by the id field
        scenario = await Scenario.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ScenarioUpdateInput,
        where: types.ScenarioWhereUniqueInput,
        include: Optional[types.ScenarioInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Scenario record.

        Parameters
        ----------
        data
            Scenario record data specifying what to update
        where
            Scenario filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Scenario model

        Returns
        -------
        prisma.models.Scenario
            The updated Scenario record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        scenario = await Scenario.prisma().update(
            where={
                'id': 'dchgibach',
            },
            data={
                # data to update the Scenario record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ScenarioWhereUniqueInput,
        data: types.ScenarioUpsertInput,
        include: Optional[types.ScenarioInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Scenario filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Scenario model

        Returns
        -------
        prisma.models.Scenario
            The created or updated Scenario record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        scenario = await Scenario.prisma().upsert(
            where={
                'id': 'fchheijjc',
            },
            data={
                'create': {
                    'id': 'fchheijjc',
                    'name': 'fbjeiiffa',
                    'impactAssessment': Json({'jhgidcgbf': True}),
                },
                'update': {
                    'name': 'fbjeiiffa',
                    'impactAssessment': Json({'jhgidcgbf': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ScenarioUpdateManyMutationInput,
        where: types.ScenarioWhereInput,
    ) -> int:
        """Update multiple Scenario records

        Parameters
        ----------
        data
            Scenario data to update the selected Scenario records to
        where
            Filter to select the Scenario records to update

        Returns
        -------
        int
            The total number of Scenario records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Scenario records
        total = await Scenario.prisma().update_many(
            data={
                'name': 'cacjdfhejh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScenarioWhereInput] = None,
        cursor: Optional[types.ScenarioWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Scenario records present in the database

        Parameters
        ----------
        select
            Select the Scenario fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Scenario filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ScenarioCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Scenario.prisma().count()

        # results: prisma.types.ScenarioCountAggregateOutput
        results = await Scenario.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ScenarioCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScenarioWhereInput] = None,
        cursor: Optional[types.ScenarioWhereUniqueInput] = None,
    ) -> types.ScenarioCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ScenarioCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScenarioWhereInput] = None,
        cursor: Optional[types.ScenarioWhereUniqueInput] = None,
    ) -> Union[int, types.ScenarioCountAggregateOutput]:
        """Count the number of Scenario records present in the database

        Parameters
        ----------
        select
            Select the Scenario fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Scenario filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ScenarioCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Scenario.prisma().count()

        # results: prisma.types.ScenarioCountAggregateOutput
        results = await Scenario.prisma().count(
            select={
                '_all': True,
                'impactAssessment': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ScenarioCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ScenarioWhereInput] = None
    ) -> int:
        """Delete multiple Scenario records.

        Parameters
        ----------
        where
            Optional Scenario filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Scenario records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Scenario records
        total = await Scenario.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ScenarioScalarFieldKeys'],
        *,
        where: Optional['types.ScenarioWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ScenarioAvgAggregateInput'] = None,
        sum: Optional['types.ScenarioSumAggregateInput'] = None,
        min: Optional['types.ScenarioMinAggregateInput'] = None,
        max: Optional['types.ScenarioMaxAggregateInput'] = None,
        having: Optional['types.ScenarioScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ScenarioCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ScenarioScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ScenarioScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ScenarioGroupByOutput']:
        """Group Scenario records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Scenario fields to group records by
        where
            Scenario filter to select records
        take
            Limit the maximum number of Scenario records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ScenarioGroupByOutput]
            A list of dictionaries representing the Scenario record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Scenario records by id values
        # and count how many records are in each group
        results = await Scenario.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SocialReportActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SocialReport]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SocialReport.prisma().query_raw(
            'SELECT * FROM SocialReport WHERE id = $1',
            'bdbifjhbbi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SocialReport
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SocialReport.prisma().query_first(
            'SELECT * FROM SocialReport WHERE timestamp = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SocialReportCreateInput,
        include: Optional[types.SocialReportInclude] = None
    ) -> _PrismaModelT:
        """Create a new SocialReport record.

        Parameters
        ----------
        data
            SocialReport record data
        include
            Specifies which relations should be loaded on the returned SocialReport model

        Returns
        -------
        prisma.models.SocialReport
            The created SocialReport record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SocialReport record from just the required fields
        socialreport = await SocialReport.prisma().create(
            data={
                # data to create a SocialReport record
                'timestamp': datetime.datetime.utcnow(),
                'location': Base64.encode(b'cbccbbcdfb'),
                'content': 'bacejedaca',
                'source': 'bhbhdahfaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SocialReportCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SocialReport records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SocialReport record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SocialReport.prisma().create_many(
            data=[
                {
                    # data to create a SocialReport record
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bfjibceaec'),
                    'content': 'ibhgcdbgd',
                    'source': 'badaffhddg',
                },
                {
                    # data to create a SocialReport record
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bbdbfcfihd'),
                    'content': 'cbagggbji',
                    'source': 'bchgafhjed',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SocialReportWhereUniqueInput,
        include: Optional[types.SocialReportInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SocialReport record.

        Parameters
        ----------
        where
            SocialReport filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SocialReport model

        Returns
        -------
        prisma.models.SocialReport
            The deleted SocialReport record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        socialreport = await SocialReport.prisma().delete(
            where={
                'id': 'heffgjdei',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SocialReportWhereUniqueInput,
        include: Optional[types.SocialReportInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SocialReport record.

        Parameters
        ----------
        where
            SocialReport filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SocialReport model

        Returns
        -------
        prisma.models.SocialReport
            The found SocialReport record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        socialreport = await SocialReport.prisma().find_unique(
            where={
                'id': 'dahihgbeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SocialReportWhereUniqueInput,
        include: Optional[types.SocialReportInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SocialReport record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SocialReport filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SocialReport model

        Returns
        -------
        prisma.models.SocialReport
            The found SocialReport record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        socialreport = await SocialReport.prisma().find_unique_or_raise(
            where={
                'id': 'bgheaejbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SocialReportWhereInput] = None,
        cursor: Optional[types.SocialReportWhereUniqueInput] = None,
        include: Optional[types.SocialReportInclude] = None,
        order: Optional[Union[types.SocialReportOrderByInput, List[types.SocialReportOrderByInput]]] = None,
        distinct: Optional[List[types.SocialReportScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SocialReport records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SocialReport records returned
        skip
            Ignore the first N results
        where
            SocialReport filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SocialReport model
        order
            Order the returned SocialReport records by any field
        distinct
            Filter SocialReport records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SocialReport]
            The list of all SocialReport records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SocialReport records
        socialreports = await SocialReport.prisma().find_many(take=10)

        # find the first 5 SocialReport records ordered by the location field
        socialreports = await SocialReport.prisma().find_many(
            take=5,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SocialReportWhereInput] = None,
        cursor: Optional[types.SocialReportWhereUniqueInput] = None,
        include: Optional[types.SocialReportInclude] = None,
        order: Optional[Union[types.SocialReportOrderByInput, List[types.SocialReportOrderByInput]]] = None,
        distinct: Optional[List[types.SocialReportScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SocialReport record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SocialReport filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SocialReport model
        order
            Order the returned SocialReport records by any field
        distinct
            Filter SocialReport records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SocialReport
            The first SocialReport record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SocialReport record ordered by the content field
        socialreport = await SocialReport.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SocialReportWhereInput] = None,
        cursor: Optional[types.SocialReportWhereUniqueInput] = None,
        include: Optional[types.SocialReportInclude] = None,
        order: Optional[Union[types.SocialReportOrderByInput, List[types.SocialReportOrderByInput]]] = None,
        distinct: Optional[List[types.SocialReportScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SocialReport record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SocialReport filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SocialReport model
        order
            Order the returned SocialReport records by any field
        distinct
            Filter SocialReport records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SocialReport
            The first SocialReport record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SocialReport record ordered by the source field
        socialreport = await SocialReport.prisma().find_first_or_raise(
            skip=1,
            order={
                'source': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SocialReportUpdateInput,
        where: types.SocialReportWhereUniqueInput,
        include: Optional[types.SocialReportInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SocialReport record.

        Parameters
        ----------
        data
            SocialReport record data specifying what to update
        where
            SocialReport filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SocialReport model

        Returns
        -------
        prisma.models.SocialReport
            The updated SocialReport record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        socialreport = await SocialReport.prisma().update(
            where={
                'id': 'bfcgifeged',
            },
            data={
                # data to update the SocialReport record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SocialReportWhereUniqueInput,
        data: types.SocialReportUpsertInput,
        include: Optional[types.SocialReportInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SocialReport filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SocialReport model

        Returns
        -------
        prisma.models.SocialReport
            The created or updated SocialReport record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        socialreport = await SocialReport.prisma().upsert(
            where={
                'id': 'jfiahhbae',
            },
            data={
                'create': {
                    'id': 'jfiahhbae',
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bbdbfcfihd'),
                    'content': 'cbagggbji',
                    'source': 'bchgafhjed',
                },
                'update': {
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bbdbfcfihd'),
                    'content': 'cbagggbji',
                    'source': 'bchgafhjed',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SocialReportUpdateManyMutationInput,
        where: types.SocialReportWhereInput,
    ) -> int:
        """Update multiple SocialReport records

        Parameters
        ----------
        data
            SocialReport data to update the selected SocialReport records to
        where
            Filter to select the SocialReport records to update

        Returns
        -------
        int
            The total number of SocialReport records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SocialReport records
        total = await SocialReport.prisma().update_many(
            data={
                'id': 'bfbdafajcb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SocialReportWhereInput] = None,
        cursor: Optional[types.SocialReportWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SocialReport records present in the database

        Parameters
        ----------
        select
            Select the SocialReport fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SocialReport filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SocialReportCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SocialReport.prisma().count()

        # results: prisma.types.SocialReportCountAggregateOutput
        results = await SocialReport.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SocialReportCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SocialReportWhereInput] = None,
        cursor: Optional[types.SocialReportWhereUniqueInput] = None,
    ) -> types.SocialReportCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SocialReportCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SocialReportWhereInput] = None,
        cursor: Optional[types.SocialReportWhereUniqueInput] = None,
    ) -> Union[int, types.SocialReportCountAggregateOutput]:
        """Count the number of SocialReport records present in the database

        Parameters
        ----------
        select
            Select the SocialReport fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SocialReport filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SocialReportCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SocialReport.prisma().count()

        # results: prisma.types.SocialReportCountAggregateOutput
        results = await SocialReport.prisma().count(
            select={
                '_all': True,
                'location': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SocialReportCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SocialReportWhereInput] = None
    ) -> int:
        """Delete multiple SocialReport records.

        Parameters
        ----------
        where
            Optional SocialReport filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SocialReport records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SocialReport records
        total = await SocialReport.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SocialReportScalarFieldKeys'],
        *,
        where: Optional['types.SocialReportWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SocialReportAvgAggregateInput'] = None,
        sum: Optional['types.SocialReportSumAggregateInput'] = None,
        min: Optional['types.SocialReportMinAggregateInput'] = None,
        max: Optional['types.SocialReportMaxAggregateInput'] = None,
        having: Optional['types.SocialReportScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SocialReportCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SocialReportScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SocialReportScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SocialReportGroupByOutput']:
        """Group SocialReport records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SocialReport fields to group records by
        where
            SocialReport filter to select records
        take
            Limit the maximum number of SocialReport records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SocialReportGroupByOutput]
            A list of dictionaries representing the SocialReport record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SocialReport records by content values
        # and count how many records are in each group
        results = await SocialReport.prisma().group_by(
            ['content'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TrafficDataActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TrafficData]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TrafficData.prisma().query_raw(
            'SELECT * FROM TrafficData WHERE id = $1',
            'caeghehde',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TrafficData
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TrafficData.prisma().query_first(
            'SELECT * FROM TrafficData WHERE timestamp = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TrafficDataCreateInput,
        include: Optional[types.TrafficDataInclude] = None
    ) -> _PrismaModelT:
        """Create a new TrafficData record.

        Parameters
        ----------
        data
            TrafficData record data
        include
            Specifies which relations should be loaded on the returned TrafficData model

        Returns
        -------
        prisma.models.TrafficData
            The created TrafficData record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TrafficData record from just the required fields
        trafficdata = await TrafficData.prisma().create(
            data={
                # data to create a TrafficData record
                'timestamp': datetime.datetime.utcnow(),
                'location': Base64.encode(b'caghgfbggd'),
                'density': 1183911900,
                'speed': 1589704933.124347,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TrafficDataCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TrafficData records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TrafficData record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TrafficData.prisma().create_many(
            data=[
                {
                    # data to create a TrafficData record
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'bdgjicijhb'),
                    'density': 1678593480,
                    'speed': 403521121.64876,
                },
                {
                    # data to create a TrafficData record
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'gahdcdhbj'),
                    'density': 1468890740,
                    'speed': 629039005.121416,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TrafficDataWhereUniqueInput,
        include: Optional[types.TrafficDataInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TrafficData record.

        Parameters
        ----------
        where
            TrafficData filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TrafficData model

        Returns
        -------
        prisma.models.TrafficData
            The deleted TrafficData record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        trafficdata = await TrafficData.prisma().delete(
            where={
                'id': 'ijigbdcbj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TrafficDataWhereUniqueInput,
        include: Optional[types.TrafficDataInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TrafficData record.

        Parameters
        ----------
        where
            TrafficData filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TrafficData model

        Returns
        -------
        prisma.models.TrafficData
            The found TrafficData record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        trafficdata = await TrafficData.prisma().find_unique(
            where={
                'id': 'gfidhicai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TrafficDataWhereUniqueInput,
        include: Optional[types.TrafficDataInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TrafficData record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TrafficData filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TrafficData model

        Returns
        -------
        prisma.models.TrafficData
            The found TrafficData record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        trafficdata = await TrafficData.prisma().find_unique_or_raise(
            where={
                'id': 'jfegcaafh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TrafficDataWhereInput] = None,
        cursor: Optional[types.TrafficDataWhereUniqueInput] = None,
        include: Optional[types.TrafficDataInclude] = None,
        order: Optional[Union[types.TrafficDataOrderByInput, List[types.TrafficDataOrderByInput]]] = None,
        distinct: Optional[List[types.TrafficDataScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TrafficData records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TrafficData records returned
        skip
            Ignore the first N results
        where
            TrafficData filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TrafficData model
        order
            Order the returned TrafficData records by any field
        distinct
            Filter TrafficData records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TrafficData]
            The list of all TrafficData records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TrafficData records
        trafficdatas = await TrafficData.prisma().find_many(take=10)

        # find the first 5 TrafficData records ordered by the location field
        trafficdatas = await TrafficData.prisma().find_many(
            take=5,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TrafficDataWhereInput] = None,
        cursor: Optional[types.TrafficDataWhereUniqueInput] = None,
        include: Optional[types.TrafficDataInclude] = None,
        order: Optional[Union[types.TrafficDataOrderByInput, List[types.TrafficDataOrderByInput]]] = None,
        distinct: Optional[List[types.TrafficDataScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TrafficData record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TrafficData filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TrafficData model
        order
            Order the returned TrafficData records by any field
        distinct
            Filter TrafficData records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TrafficData
            The first TrafficData record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TrafficData record ordered by the density field
        trafficdata = await TrafficData.prisma().find_first(
            skip=1,
            order={
                'density': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TrafficDataWhereInput] = None,
        cursor: Optional[types.TrafficDataWhereUniqueInput] = None,
        include: Optional[types.TrafficDataInclude] = None,
        order: Optional[Union[types.TrafficDataOrderByInput, List[types.TrafficDataOrderByInput]]] = None,
        distinct: Optional[List[types.TrafficDataScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TrafficData record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TrafficData filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TrafficData model
        order
            Order the returned TrafficData records by any field
        distinct
            Filter TrafficData records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TrafficData
            The first TrafficData record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TrafficData record ordered by the speed field
        trafficdata = await TrafficData.prisma().find_first_or_raise(
            skip=1,
            order={
                'speed': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TrafficDataUpdateInput,
        where: types.TrafficDataWhereUniqueInput,
        include: Optional[types.TrafficDataInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TrafficData record.

        Parameters
        ----------
        data
            TrafficData record data specifying what to update
        where
            TrafficData filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TrafficData model

        Returns
        -------
        prisma.models.TrafficData
            The updated TrafficData record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        trafficdata = await TrafficData.prisma().update(
            where={
                'id': 'bcbeiajjfa',
            },
            data={
                # data to update the TrafficData record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TrafficDataWhereUniqueInput,
        data: types.TrafficDataUpsertInput,
        include: Optional[types.TrafficDataInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TrafficData filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TrafficData model

        Returns
        -------
        prisma.models.TrafficData
            The created or updated TrafficData record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        trafficdata = await TrafficData.prisma().upsert(
            where={
                'id': 'baehicaajf',
            },
            data={
                'create': {
                    'id': 'baehicaajf',
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'gahdcdhbj'),
                    'density': 1468890740,
                    'speed': 629039005.121416,
                },
                'update': {
                    'timestamp': datetime.datetime.utcnow(),
                    'location': Base64.encode(b'gahdcdhbj'),
                    'density': 1468890740,
                    'speed': 629039005.121416,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TrafficDataUpdateManyMutationInput,
        where: types.TrafficDataWhereInput,
    ) -> int:
        """Update multiple TrafficData records

        Parameters
        ----------
        data
            TrafficData data to update the selected TrafficData records to
        where
            Filter to select the TrafficData records to update

        Returns
        -------
        int
            The total number of TrafficData records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TrafficData records
        total = await TrafficData.prisma().update_many(
            data={
                'id': 'bdachdeiga'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TrafficDataWhereInput] = None,
        cursor: Optional[types.TrafficDataWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TrafficData records present in the database

        Parameters
        ----------
        select
            Select the TrafficData fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TrafficData filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TrafficDataCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TrafficData.prisma().count()

        # results: prisma.types.TrafficDataCountAggregateOutput
        results = await TrafficData.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TrafficDataCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TrafficDataWhereInput] = None,
        cursor: Optional[types.TrafficDataWhereUniqueInput] = None,
    ) -> types.TrafficDataCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TrafficDataCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TrafficDataWhereInput] = None,
        cursor: Optional[types.TrafficDataWhereUniqueInput] = None,
    ) -> Union[int, types.TrafficDataCountAggregateOutput]:
        """Count the number of TrafficData records present in the database

        Parameters
        ----------
        select
            Select the TrafficData fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TrafficData filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TrafficDataCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TrafficData.prisma().count()

        # results: prisma.types.TrafficDataCountAggregateOutput
        results = await TrafficData.prisma().count(
            select={
                '_all': True,
                'location': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TrafficDataCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TrafficDataWhereInput] = None
    ) -> int:
        """Delete multiple TrafficData records.

        Parameters
        ----------
        where
            Optional TrafficData filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TrafficData records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TrafficData records
        total = await TrafficData.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TrafficDataScalarFieldKeys'],
        *,
        where: Optional['types.TrafficDataWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TrafficDataAvgAggregateInput'] = None,
        sum: Optional['types.TrafficDataSumAggregateInput'] = None,
        min: Optional['types.TrafficDataMinAggregateInput'] = None,
        max: Optional['types.TrafficDataMaxAggregateInput'] = None,
        having: Optional['types.TrafficDataScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TrafficDataCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TrafficDataScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TrafficDataScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TrafficDataGroupByOutput']:
        """Group TrafficData records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TrafficData fields to group records by
        where
            TrafficData filter to select records
        take
            Limit the maximum number of TrafficData records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TrafficDataGroupByOutput]
            A list of dictionaries representing the TrafficData record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TrafficData records by density values
        # and count how many records are in each group
        results = await TrafficData.prisma().group_by(
            ['density'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TrafficLightActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TrafficLight]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TrafficLight.prisma().query_raw(
            'SELECT * FROM TrafficLight WHERE id = $1',
            'ijdafccef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TrafficLight
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TrafficLight.prisma().query_first(
            'SELECT * FROM TrafficLight WHERE location = $1',
            Base64.encode(b'ciaaiddag'),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TrafficLightCreateInput,
        include: Optional[types.TrafficLightInclude] = None
    ) -> _PrismaModelT:
        """Create a new TrafficLight record.

        Parameters
        ----------
        data
            TrafficLight record data
        include
            Specifies which relations should be loaded on the returned TrafficLight model

        Returns
        -------
        prisma.models.TrafficLight
            The created TrafficLight record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TrafficLight record from just the required fields
        trafficlight = await TrafficLight.prisma().create(
            data={
                # data to create a TrafficLight record
                'location': Base64.encode(b'fejggijff'),
                'currentState': 'hghjaaai',
                'redStateDuration': 2098299345,
                'greenStateDuration': 245900342,
                'createdAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TrafficLightCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TrafficLight records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TrafficLight record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TrafficLight.prisma().create_many(
            data=[
                {
                    # data to create a TrafficLight record
                    'location': Base64.encode(b'ibbigdigd'),
                    'currentState': 'bdiiiabbii',
                    'redStateDuration': 752577037,
                    'greenStateDuration': 1187663298,
                    'createdAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a TrafficLight record
                    'location': Base64.encode(b'hgjgibdgd'),
                    'currentState': 'bcbecjfice',
                    'redStateDuration': 1021417993,
                    'greenStateDuration': 351503374,
                    'createdAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TrafficLightWhereUniqueInput,
        include: Optional[types.TrafficLightInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TrafficLight record.

        Parameters
        ----------
        where
            TrafficLight filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TrafficLight model

        Returns
        -------
        prisma.models.TrafficLight
            The deleted TrafficLight record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        trafficlight = await TrafficLight.prisma().delete(
            where={
                'id': 'bdcbbieibf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TrafficLightWhereUniqueInput,
        include: Optional[types.TrafficLightInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TrafficLight record.

        Parameters
        ----------
        where
            TrafficLight filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TrafficLight model

        Returns
        -------
        prisma.models.TrafficLight
            The found TrafficLight record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        trafficlight = await TrafficLight.prisma().find_unique(
            where={
                'id': 'dgjhdcggi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TrafficLightWhereUniqueInput,
        include: Optional[types.TrafficLightInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TrafficLight record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TrafficLight filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TrafficLight model

        Returns
        -------
        prisma.models.TrafficLight
            The found TrafficLight record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        trafficlight = await TrafficLight.prisma().find_unique_or_raise(
            where={
                'id': 'bbjbcdfabd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TrafficLightWhereInput] = None,
        cursor: Optional[types.TrafficLightWhereUniqueInput] = None,
        include: Optional[types.TrafficLightInclude] = None,
        order: Optional[Union[types.TrafficLightOrderByInput, List[types.TrafficLightOrderByInput]]] = None,
        distinct: Optional[List[types.TrafficLightScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TrafficLight records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TrafficLight records returned
        skip
            Ignore the first N results
        where
            TrafficLight filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TrafficLight model
        order
            Order the returned TrafficLight records by any field
        distinct
            Filter TrafficLight records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TrafficLight]
            The list of all TrafficLight records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TrafficLight records
        trafficlights = await TrafficLight.prisma().find_many(take=10)

        # find the first 5 TrafficLight records ordered by the currentState field
        trafficlights = await TrafficLight.prisma().find_many(
            take=5,
            order={
                'currentState': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TrafficLightWhereInput] = None,
        cursor: Optional[types.TrafficLightWhereUniqueInput] = None,
        include: Optional[types.TrafficLightInclude] = None,
        order: Optional[Union[types.TrafficLightOrderByInput, List[types.TrafficLightOrderByInput]]] = None,
        distinct: Optional[List[types.TrafficLightScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TrafficLight record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TrafficLight filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TrafficLight model
        order
            Order the returned TrafficLight records by any field
        distinct
            Filter TrafficLight records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TrafficLight
            The first TrafficLight record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TrafficLight record ordered by the redStateDuration field
        trafficlight = await TrafficLight.prisma().find_first(
            skip=1,
            order={
                'redStateDuration': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TrafficLightWhereInput] = None,
        cursor: Optional[types.TrafficLightWhereUniqueInput] = None,
        include: Optional[types.TrafficLightInclude] = None,
        order: Optional[Union[types.TrafficLightOrderByInput, List[types.TrafficLightOrderByInput]]] = None,
        distinct: Optional[List[types.TrafficLightScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TrafficLight record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TrafficLight filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TrafficLight model
        order
            Order the returned TrafficLight records by any field
        distinct
            Filter TrafficLight records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TrafficLight
            The first TrafficLight record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TrafficLight record ordered by the greenStateDuration field
        trafficlight = await TrafficLight.prisma().find_first_or_raise(
            skip=1,
            order={
                'greenStateDuration': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TrafficLightUpdateInput,
        where: types.TrafficLightWhereUniqueInput,
        include: Optional[types.TrafficLightInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TrafficLight record.

        Parameters
        ----------
        data
            TrafficLight record data specifying what to update
        where
            TrafficLight filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TrafficLight model

        Returns
        -------
        prisma.models.TrafficLight
            The updated TrafficLight record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        trafficlight = await TrafficLight.prisma().update(
            where={
                'id': 'gchfgbcec',
            },
            data={
                # data to update the TrafficLight record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TrafficLightWhereUniqueInput,
        data: types.TrafficLightUpsertInput,
        include: Optional[types.TrafficLightInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TrafficLight filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TrafficLight model

        Returns
        -------
        prisma.models.TrafficLight
            The created or updated TrafficLight record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        trafficlight = await TrafficLight.prisma().upsert(
            where={
                'id': 'bihcjfcjah',
            },
            data={
                'create': {
                    'id': 'bihcjfcjah',
                    'location': Base64.encode(b'hgjgibdgd'),
                    'currentState': 'bcbecjfice',
                    'redStateDuration': 1021417993,
                    'greenStateDuration': 351503374,
                    'createdAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'location': Base64.encode(b'hgjgibdgd'),
                    'currentState': 'bcbecjfice',
                    'redStateDuration': 1021417993,
                    'greenStateDuration': 351503374,
                    'createdAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TrafficLightUpdateManyMutationInput,
        where: types.TrafficLightWhereInput,
    ) -> int:
        """Update multiple TrafficLight records

        Parameters
        ----------
        data
            TrafficLight data to update the selected TrafficLight records to
        where
            Filter to select the TrafficLight records to update

        Returns
        -------
        int
            The total number of TrafficLight records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TrafficLight records
        total = await TrafficLight.prisma().update_many(
            data={
                'recommendedState': 'bhjdcicaii'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TrafficLightWhereInput] = None,
        cursor: Optional[types.TrafficLightWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TrafficLight records present in the database

        Parameters
        ----------
        select
            Select the TrafficLight fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TrafficLight filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TrafficLightCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TrafficLight.prisma().count()

        # results: prisma.types.TrafficLightCountAggregateOutput
        results = await TrafficLight.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TrafficLightCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TrafficLightWhereInput] = None,
        cursor: Optional[types.TrafficLightWhereUniqueInput] = None,
    ) -> types.TrafficLightCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TrafficLightCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TrafficLightWhereInput] = None,
        cursor: Optional[types.TrafficLightWhereUniqueInput] = None,
    ) -> Union[int, types.TrafficLightCountAggregateOutput]:
        """Count the number of TrafficLight records present in the database

        Parameters
        ----------
        select
            Select the TrafficLight fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TrafficLight filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TrafficLightCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TrafficLight.prisma().count()

        # results: prisma.types.TrafficLightCountAggregateOutput
        results = await TrafficLight.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TrafficLightCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TrafficLightWhereInput] = None
    ) -> int:
        """Delete multiple TrafficLight records.

        Parameters
        ----------
        where
            Optional TrafficLight filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TrafficLight records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TrafficLight records
        total = await TrafficLight.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TrafficLightScalarFieldKeys'],
        *,
        where: Optional['types.TrafficLightWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TrafficLightAvgAggregateInput'] = None,
        sum: Optional['types.TrafficLightSumAggregateInput'] = None,
        min: Optional['types.TrafficLightMinAggregateInput'] = None,
        max: Optional['types.TrafficLightMaxAggregateInput'] = None,
        having: Optional['types.TrafficLightScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TrafficLightCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TrafficLightScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TrafficLightScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TrafficLightGroupByOutput']:
        """Group TrafficLight records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TrafficLight fields to group records by
        where
            TrafficLight filter to select records
        take
            Limit the maximum number of TrafficLight records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TrafficLightGroupByOutput]
            A list of dictionaries representing the TrafficLight record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TrafficLight records by location values
        # and count how many records are in each group
        results = await TrafficLight.prisma().group_by(
            ['location'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models